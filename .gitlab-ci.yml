stages:
  - verify
  - build
  - deploy

# Répertoires utiles dans le monorepo
variables:
  FRONTEND_CONTEXT: "apps/frontend-next"
  API_CONTEXT: "apps/api-nest"

# -------------------------------------------------
# 0) VERIFY (MR / feature / dev) : build rapide sans Docker
# -------------------------------------------------
verify:frontend:
  stage: verify
  image: node:20-alpine
  variables:
      DATABASE_URL: "postgresql://user:pass@localhost:5432/dummy?schema=public"
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH && $CI_COMMIT_BRANCH != "main"'
    - when: never
  script:
    - corepack enable
    - pnpm -v || npm i -g pnpm
    - pnpm install --frozen-lockfile
    - pnpm --filter frontend build

verify:api:
  stage: verify
  image: node:20-alpine
  variables:
      DATABASE_URL: "postgresql://user:pass@localhost:5432/dummy?schema=public"
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH && $CI_COMMIT_BRANCH != "main"'
    - when: never
  script:
    - corepack enable
    - pnpm -v || npm i -g pnpm
    - pnpm install --frozen-lockfile
    - pnpm --filter api build

# -------------------------------------------------
# 1) BUILD & PUSH avec Kaniko (main & tags)
# -------------------------------------------------
.build_with_kaniko:
  stage: build
  image:
    name: gcr.io/kaniko-project/executor:latest
    entrypoint: [""]
  variables:
    DOCKER_CONFIG: /kaniko/.docker
  before_script:
    - mkdir -p "$DOCKER_CONFIG"
    - echo "{\"auths\":{\"$CI_REGISTRY\":{\"username\":\"$CI_REGISTRY_USER\",\"password\":\"$CI_REGISTRY_PASSWORD\"}}}" > "$DOCKER_CONFIG/config.json"

build:images:
  extends: .build_with_kaniko
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
    - if: '$CI_COMMIT_TAG'
    - when: never
  script:
    # Tagging
    - |
      if [ -n "$CI_COMMIT_TAG" ]; then
        FRONT_TAG="prod"
        API_TAG="prod"
      else
        FRONT_TAG="staging"
        API_TAG="staging"
      fi
    # Frontend
    - >
      /kaniko/executor
      --context "${CI_PROJECT_DIR}"
      --dockerfile "${FRONTEND_CONTEXT}/Dockerfile"
      --destination "${CI_REGISTRY_IMAGE}/frontend:${FRONT_TAG}"
      --cache=true
      --cache-repo="${KANIKO_CACHE_REPO}"
    # API
    - >
      /kaniko/executor
      --context "${CI_PROJECT_DIR}"
      --dockerfile "${API_CONTEXT}/Dockerfile"
      --destination "${CI_REGISTRY_IMAGE}/api:${API_TAG}"
      --build-arg DATABASE_URL="postgresql://user:pass@localhost:5432/dummy?schema=public"
      --cache=true
      --cache-repo="${KANIKO_CACHE_REPO}"

# -------------------------------------------------
# 2) DEPLOY STAGING (push sur main)
# -------------------------------------------------
deploy:staging:
  stage: deploy
  image: alpine:3.20
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
    - when: never
  before_script:
    - apk add --no-cache openssh-client
    - eval "$(ssh-agent -s)"
    - echo "$SSH_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh && chmod 700 ~/.ssh
    - ssh-keyscan -p "$SSH_PORT" -H "$SSH_HOST" >> ~/.ssh/known_hosts
  script:
    - |
      ssh -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash -se << 'EOF'
      set -euo pipefail
      mkdir -p "$STAGING_DEPLOY_DIR"
      cd "$STAGING_DEPLOY_DIR"

      # Génère/MAJ les .env
      cat > api.env <<EOT
      NODE_ENV=production
      PORT=3001
      DATABASE_URL=$STAGING_DATABASE_URL
      JWT_SECRET=${JWT_SECRET_STAGING:-change_me}
      API_BASE_URL=https://api.staging.mindfulspace.be
      FRONTEND_BASE_URL=https://staging.mindfulspace.be
      EOT

      cat > db.env <<EOT
      POSTGRES_PASSWORD=${STAGING_DB_PASSWORD:-postgres}
      EOT

      # Compose file est déjà présent dans le dossier
      docker login "$CI_REGISTRY" -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD"
      docker compose pull
      docker compose up -d --remove-orphans

      # Migrations & seed (en staging uniquement)
      docker compose exec -T api sh -lc 'node -v >/dev/null 2>&1 && npx prisma migrate deploy'
      docker compose exec -T api sh -lc 'npx prisma db seed || true'
      EOF
  needs: ["build:images"]

# -------------------------------------------------
# 3) DEPLOY PRODUCTION (tag)
# -------------------------------------------------
deploy:prod:
  stage: deploy
  image: alpine:3.20
  rules:
    - if: '$CI_COMMIT_TAG'
    - when: never
  before_script:
    - apk add --no-cache openssh-client
    - eval "$(ssh-agent -s)"
    - echo "$SSH_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh && chmod 700 ~/.ssh
    - ssh-keyscan -p "$SSH_PORT" -H "$SSH_HOST" >> ~/.ssh/known_hosts
  script:
    - |
      ssh -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash -se << 'EOF'
      set -euo pipefail
      mkdir -p "$PROD_DEPLOY_DIR"
      cd "$PROD_DEPLOY_DIR"

      cat > api.env <<EOT
      NODE_ENV=production
      PORT=3001
      DATABASE_URL=$PROD_DATABASE_URL
      JWT_SECRET=${JWT_SECRET_PROD:-change_me}
      API_BASE_URL=https://api.mindfulspace.be
      FRONTEND_BASE_URL=https://mindfulspace.be
      EOT

      cat > db.env <<EOT
      POSTGRES_PASSWORD=${PROD_DB_PASSWORD:-postgres}
      EOT

      docker login "$CI_REGISTRY" -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD"
      docker compose pull
      docker compose up -d --remove-orphans

      # Migrations sans seed en prod
      docker compose exec -T api sh -lc 'npx prisma migrate deploy'
      EOF
  needs: ["build:images"]
