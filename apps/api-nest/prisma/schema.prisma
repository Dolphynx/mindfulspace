generator client {
  provider = "prisma-client-js" // génère le client TypeScript Prisma
}

datasource db {
  provider = "postgresql"       // base cible : PostgreSQL
  url      = env("DATABASE_URL") // chaîne de connexion injectée via l'env
}

enum MeditationMode {
  TIMER   // séance minutée, sans média
  AUDIO   // lecture audio (fichiers mp3, etc.)
  VIDEO   // lecture vidéo (YouTube, autres)
  VISUAL  // exercise purement visuel (animations, SVG, etc.)
}

enum MeditationSessionSource {
  GUIDED      // séance guidée via un contenu (audio / visuel)
  MANUAL      // séance encodée manuellement
  QUICK_TIMER // séance créée via un simple timer rapide
}

enum MeditationVisualType {
  BREATHING_WAVE // animation type vague de respiration
  LOTUS_OPENING  // lotus qui s’ouvre / se ferme
  CIRCLE_PULSE   // cercle qui pulse au rythme de la respiration
}

// Données de test pour un graphique sur la home
model TestData {
  id          String   @id @default(uuid())
  metricName  String        // nom logique de la métrique
  label       String        // libellé affiché dans le graphique
  metricValue Int           // valeur numérique à tracer
  createdAt   DateTime @default(now())
}

model SleepSession {
  id          String   @id @default(uuid())
  hours       Int           // nombre d'heures de sommeil
  quality     Int?          // évaluation subjective (échelle simple)
  dateSession DateTime      // date réelle de la nuit
  dateCreated DateTime @default(now()) // date d’encodage en DB

  user   User?   @relation(fields: [userId], references: [id])
  userId String? // utilisateur propriétaire (nullable pour tests)
}

model MeditationSession {
  id String @id @default(cuid())

  userId String                    // FK vers l'utilisateur
  user   User   @relation(fields: [userId], references: [id])

  // Origine de la séance (wizard, manuel, quick timer…)
  source MeditationSessionSource

  // TYPE choisi par l'utilisateur
  meditationTypeId String
  meditationType   MeditationType @relation("SessionActualType", fields: [meditationTypeId], references: [id])

  // Contenu GUIDED (optionnel : TIMER simple n'en a pas)
  meditationContentId String?
  meditationContent   MeditationContent? @relation(fields: [meditationContentId], references: [id])

  startedAt       DateTime? // début effectif de la séance
  endedAt         DateTime? // fin effective de la séance
  durationSeconds Int       // durée stockée en secondes

  moodBefore Int? // humeur avant la séance (1–5)
  moodAfter  Int? // humeur après la séance (1–5)
  notes      String? // notes libres éventuelles

  createdAt DateTime @default(now())

  @@index([userId])              // requêtes filtrées par utilisateur
  @@index([meditationTypeId])    // analytics par type de méditation
  @@index([meditationContentId]) // lien rapide vers le contenu utilisé
  @@map("meditation_session")    // nom de table explicite en DB
}

model MeditationType {
  id        String  @id @default(cuid())
  slug      String  @unique         // identifiant stable pour i18n & front
  //name        String
  //description String?
  isActive  Boolean @default(true)  // permet de masquer un type sans le supprimer
  sortOrder Int?                    // ordre d’affichage dans le catalogue

  contents MeditationContent[] @relation("ContentDefaultType") // contenus dont c’est le type par défaut
  sessions MeditationSession[] @relation("SessionActualType")  // séances réellement associées à ce type

  @@map("meditation_type")
}

model MeditationContent {
  id          String  @id @default(cuid())
  title       String        // titre visible côté front
  description String?       // description courte du contenu

  // Mode : TIMER / AUDIO / VIDEO / VISUAL
  mode MeditationMode

  // Type par défaut pour les sessions lancées par ce contenu
  defaultMeditationTypeId String
  defaultMeditationType   MeditationType @relation("ContentDefaultType", fields: [defaultMeditationTypeId], references: [id])

  // Durées (suggestions / bornes) pour filtrage et UX
  defaultDurationSeconds Int? // durée suggérée par défaut
  minDurationSeconds     Int? // durée minimale sensée pour ce contenu
  maxDurationSeconds     Int? // durée maximale sensée pour ce contenu

  // Media unique (audio OU vidéo), optionnel si TIMER/VISUAL
  mediaUrl String? // ex: "/audio/respiration.mp3" ou "https://youtu.be/..."

  isActive  Boolean @default(true)   // pour masquer un contenu sans le supprimer
  isPremium Boolean  @default(false) // restreint aux utilisateurs premium
  sortOrder Int?                     // tri dans les listes (wizard, catalogue)

  // Relations
  visualConfig MeditationVisualConfig? // config JSON spécifique si VISUAL
  sessions     MeditationSession[]     // sessions GUIDED basées sur ce contenu
  programItems MeditationProgramItem[] // utilisé dans des programmes

  @@map("meditation_content")
}

model MeditationVisualConfig {
  id String @id @default(cuid())

  meditationContentId String            @unique // un visuel config par contenu
  meditationContent   MeditationContent @relation(fields: [meditationContentId], references: [id])

  visualType MeditationVisualType // type d'animation (lotus, vagues, etc.)

    /// Configuration sérialisée, adaptée au type de visuel.
    /// Pour le cercle qui "respire", on utilise par exemple :
    /// {
    ///   "totalCycles": 3,
    ///   "inhaleMs": 4000,
    ///   "holdFullMs": 4000,
    ///   "exhaleMs": 4000,
    ///   "holdEmptyMs": 0,
    ///   "minScale": 0.9,
    ///   "maxScale": 1.1
    /// }
  configJson Json // ex: { "breathIn": 5, "breathOut": 5, "cycles": 12 }

  @@map("meditation_visual_config")
}

/**
 * Programmes de méditation (séquences de MeditationContent)
 */
model MeditationProgram {
  id          String  @id @default(cuid())
  title       String        // nom du programme (ex: "Débuter la méditation")
  description String?
  isActive    Boolean @default(true)  // permet de cacher un programme
  isPremium   Boolean @default(false) // programme réservé aux abonnés
  sortOrder   Int?                    // ordre d’affichage dans les listes

  items     MeditationProgramItem[]
  resources Resource[] // ressources éditoriales qui pointent vers ce programme

  @@map("meditation_program")
}

model MeditationProgramItem {
  id                  String @id @default(cuid())
  meditationProgramId String // FK vers le programme
  meditationContentId String // FK vers le contenu de méditation
  order               Int    // position dans la séquence (1, 2, 3…)

  meditationProgram MeditationProgram @relation(fields: [meditationProgramId], references: [id])
  meditationContent MeditationContent @relation(fields: [meditationContentId], references: [id])

  @@map("meditation_program_item")
}

model WorkoutSession {
  id          String   @id @default(uuid())
  quality     Int?          // évaluation subjective de la séance
  dateSession DateTime      // jour de l’entraînement
  dateCreated DateTime @default(now())

  exerciceSessions ExerciceSession[] // exercices détaillés composant la séance

  user   User?   @relation(fields: [userId], references: [id])
  userId String? // utilisateur propriétaire
}

model ExerciceType {
  id          String         @id @default(uuid())
  name        String         @unique
  Description String

  exerciceSessions ExerciceSession[]
  steps            ExerciceStep[]   // all the steps for this exercise type
  workoutProgramExercices WorkoutProgramExercice[]
}

model ExerciceStep {
  id             String        @id @default(uuid())
  exerciceTypeId String
  exerciceType   ExerciceType  @relation(fields: [exerciceTypeId], references: [id])

  order          Int           // step number: 1, 2, 3, ...
  title          String?       // optional, e.g. "Starting position"
  description    String        // explanation for this step
  imageUrl       String?       // URL of the image (e.g. S3, Cloudinary, /public, etc.)

  @@unique([exerciceTypeId, order]) // ensures you don’t have two “step 1” for the same exercise
}


model ExerciceSession {
  workoutSessionId String // FK vers la séance globale
  exerciceTypeId   String // FK vers le type d'exercise

  workoutSession WorkoutSession @relation(fields: [workoutSessionId], references: [id])
  exerciceType   ExerciceType   @relation(fields: [exerciceTypeId], references: [id])

  repetitionCount Int // nombre de répétitions / unités pour cet exercise

  @@id([workoutSessionId, exerciceTypeId]) // clé composite (un type par séance)
}

model WorkoutProgram {
  id          String                @id @default(uuid())
  title       String
  description String?
  createdAt   DateTime              @default(now())

  days        WorkoutProgramDay[]
}

model WorkoutProgramDay {
  id               String               @id @default(uuid())
  workoutProgramId String
  workoutProgram   WorkoutProgram       @relation(fields: [workoutProgramId], references: [id])

  order            Int                  // Day order inside the program (1, 2, 3...)
  title            String               // e.g. "Day A – Upper Body"

  weekday          Int?                 // 1 = Monday ... 7 = Sunday, optional

  exercices        WorkoutProgramExercice[]
}

model WorkoutProgramExercice {
  id                String        @id @default(uuid())
  programDayId      String
  exerciceTypeId    String

  programDay        WorkoutProgramDay @relation(fields: [programDayId], references: [id])
  exerciceType      ExerciceType      @relation(fields: [exerciceTypeId], references: [id])

  defaultRepetitionCount Int?
  defaultSets            Int?
}


model User {
  id          String  @id @default(cuid())
  email       String  @unique
  displayName String?
  password    String? // Nullable for OAuth-only users

  emailVerified Boolean @default(false)
  isActive      Boolean @default(true) // For soft deletes / account suspension

  workoutSessions    WorkoutSession[]
  sleepSessions      SleepSession[]
  meditationSessions MeditationSession[]

  // Auth relations
  emailVerificationTokens EmailVerificationToken[]
  refreshTokens           RefreshToken[]
  passwordResetTokens     PasswordResetToken[]
  oauthAccounts           OAuthAccount[]
  userRoles               UserRole[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt     // mis à jour automatiquement à chaque write
}

// Email verification tokens
model EmailVerificationToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([token])
}

// Refresh tokens (stored in DB for security)
model RefreshToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  createdAt DateTime @default(now())

  // Track device/session info for security
  userAgent String?
  ipAddress String?

  @@index([userId])
  @@index([token])
}

// Password reset tokens
model PasswordResetToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  createdAt DateTime @default(now())
  usedAt    DateTime? // Track if token was used

  @@index([userId])
  @@index([token])
}

// OAuth accounts (Google, GitHub, etc.)
model OAuthAccount {
  id           String @id @default(cuid())
  provider     String // "google", "github", etc.
  providerId   String // User ID from the OAuth provider
  userId       String
  user         User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken  String?
  refreshToken String?
  expiresAt    DateTime?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@unique([provider, providerId])
  @@index([userId])
}

// Roles for RBAC
model Role {
  id          String   @id @default(cuid())
  name        String   @unique // e.g., "admin", "user", "coach", "premium"
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  userRoles       UserRole[]
  rolePermissions RolePermission[]
}

// Join table for User-Role (many-to-many)
model UserRole {
  userId String
  roleId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  role   Role   @relation(fields: [roleId], references: [id], onDelete: Cascade)

  assignedAt DateTime @default(now())

  @@id([userId, roleId])
  @@index([userId])
  @@index([roleId])
}

// Permissions for fine-grained access control
model Permission {
  id          String   @id @default(cuid())
  name        String   @unique // e.g., "sessions:create", "users:delete", "objectives:read"
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  rolePermissions RolePermission[]
}

// Join table for Role-Permission (many-to-many)
model RolePermission {
  roleId       String
  permissionId String
  role         Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  assignedAt DateTime @default(now())

  @@id([roleId, permissionId])
  @@index([roleId])
  @@index([permissionId])
}

/**
 * model Objective { ... }
 */

enum ObjectiveFrequency {
  DAILY   // objectif journalier
  WEEKLY  // objectif hebdomadaire
  MONTHLY // objectif mensuel
}

enum ObjectiveDurationUnit {
  DAY   // unité jour
  WEEK  // unité semaine
  MONTH // unité mois
}

enum ResourceType {
  ARTICLE          // article texte long
  VIDEO            // ressource vidéo
  MEDITATION_PROGRAM // lien vers un programme de méditation
  WORKOUT_PROGRAM  // futur : programme d'entraînement
  GUIDE            // guide / fiche pratique structurée
}

model ResourceCategory {
  id        String  @id @default(uuid())
  name      String        // nom de la catégorie (ex: "Sommeil")
  slug      String  @unique // identifiant stable pour routing / filtres
  iconEmoji String? // petit pictogramme dans l’UI (optionnel)

  resources Resource[]
}

model ResourceTag {
  id   String @id @default(uuid())
  name String        // libellé lisible (ex: "Stress")
  slug String @unique // identifiant pour filtres / URL

  resources ResourceTagOnResource[]
}

model Resource {
  id          String       @id @default(uuid())
  title       String             // titre éditorial
  slug        String       @unique // slug pour URL
  summary     String             // résumé court (teaser)
  content     String             // contenu complet (markdown, HTML…)
  type        ResourceType       // type de ressource (article, vidéo…)
  isPremium   Boolean      @default(false) // contenu premium ou non
  isFeatured  Boolean      @default(false) // mis en avant sur la home
  authorName  String?             // nom de l’auteur si pertinent
  readTimeMin Int?               // estimation du temps de lecture
  externalUrl String?            // lien externe éventuel (YouTube, blog…)

  categoryId String
  category   ResourceCategory @relation(fields: [categoryId], references: [id])

  // Lien optionnel vers un programme de méditation
  meditationProgramId String?
  meditationProgram   MeditationProgram? @relation(fields: [meditationProgramId], references: [id])

  // (WorkoutProgram => à mettre en place)
  tags ResourceTagOnResource[] // jonction N-N avec les tags

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([title])   // recherche plein texte partielle sur le titre
  @@index([summary]) // idem pour le résumé
}

model ResourceTagOnResource {
  resourceId String
  tagId      String

  resource Resource    @relation(fields: [resourceId], references: [id])
  tag      ResourceTag @relation(fields: [tagId], references: [id])

  @@id([resourceId, tagId]) // table de jonction N-N (clé composite)
}
